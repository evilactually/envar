What Is It?

   A console application for managing Windows environment variables

Why Make This?

    If you are a developer and you install lots of tools that you need to have
    on your PATH, you probably have faced name conflicts, general clutter
    or even ran our of space to keep all your paths. On Linux it's not much of 
    a problem since you can neatly keep all your variables in bash scripts. 
    On Windows however there isn't any easy way to persistently change
    them without relying on awkward user interface or tweaking deeply hidden 
    registry keys.

    Envar provides a simple script syntax for setting, creating and removing 
    environment variables in either system or user scopes. It can be used 
    directly from command line or as interpreter for script files. All changes 
    are made on the registry so they are visible between applications
    and persist after reboots.

    Envar doesn't enforce any particular work-flow, it just merely provides an 
    interpreter for a script syntax. How you use it is up to you.

Compiling
    
    Requirements:
        Chicken Scheme
        MinGW
        Additional eggs: defstruct, test (only if you want to run tests)

    If you have working chicken scheme and MinGW just run make in bash shell:

        make

        This will produce a non portable executable that will depend on 
        chicken runtime

    To compile a portable executable with chicken runtime included:

        make envar-deploy

    Other targets:

        make clean

        make tests

Binary Distribution:

    Latest portable binary can be downloaded from:

        https://dl.dropboxusercontent.com/u/23611520/envar-0.9.zip

Introduction

    Before you do any damage to your environment variables, save them to file:

        envar -e my_vars_when_my_computer_was_still_ working.env

    To load them back:

        envar -i my_vars_when_my_computer_was_still_working.env

    A very common task is to add some directory to PATH variable. Let's add 
    "C:\Java\bin" to user PATH:
    
        envar PATH : [%PATH%;C:\Java\bin] (DON'T ACTUALLY RUN IT, 
                                           IT WILL SET YOUR HAIR ON FIRE)

    Assuming you are using normal cmd.exe shell, %PATH% should evaluate to it's 
    current value and the result string will be passed to envar as argument.

    Be warned though that it will fully expand not only %PATH% variable itself, 
    but any variables inside of it as well. In general %PATH% doesn't look the same 
    as in registry when it's evaluated by cmd.exe. If you  want to get the 
    exact value of PATH use $() syntax to let the Envar handle variable expansion:

        envar PATH : [$(PATH);C:\Java\bin] (This is the recommended way)
    
        $(PATH) is evaluated by Envar to value of user variable named PATH

    The only issue, if you are using Linux-like shell on windows it may like
    to interpret $() as it's own sub-shell, so you may want to surround the whole
    expression in single quotes 'PATH : [$(PATH);C:\Java\bin]'

    If you wanted to set PATH variable in SYSTEM scope instead of the default USER scope, 
    you can specify system scope by prepending @ sign before variable name. Same syntax 
    is used inside $() block as well:

        envar @PATH : [$(@PATH);C:\Java\bin]

    Interesting property of $() blocks is that they work anywhere, not just 
    inside values, because they are implemented as simple text replacements. 
    You can easily use them to generate any part of script including variable names:

        $(VARIABLE_NAME) : [VALUE]

    There's one more hidden feature of $(), you can execute any command with it
    if you prepend contents with "shell" keyword:

        MYVAR : [$(shell dir)]
    
        It will stuff a directory listing into a variable, if that may serve any purpose.
    
    This is akin to syntax used in Unix make files. It's not really useful for anything
    and was simply added for completeness sake.

    Variables like PATH are very big and convoluted, so to help you organize scripts, you
    can separate values into multiple brackets:

        envar @PATH : [$(@PATH);]
                      [C:\Java\bin;]
                      [C:\Ruby\bin;]
                      [C:\chicken\bin;]

        It's not sensitive to whitespace, you can format it anyway you want.
        Contents of brackets are concatenated together during assignment.

    As was shown, you can keep your scripts in files and load them with -i option:

        envar.exe -i myvars.env

    Or save all current variables into files with -e

        envar.exe -e myvars.env    

    If file option is absent Envar will work with standard input/output pipe:

        Print exported script to terminal:
        envar.exe -e 
       
        Type script interactively in terminal (press Ctrl-Z to print EOF)
        envar.exe -i

        Pipe output from other commands:
        echo "MYVAR : [VALUE]" | envar -i

    Removing variables. When you assigned variables you used ":" operator. 
    Now to remove, you have "-" operator:

        MYVAR -

    Scope modifier @ can be used to remove variable from SYSTEM scope:

        @MYVAR -

    There's a less useful sister command, to create variable, which just creates 
    an empty variable:

        MYVAR +

    Lastly your scripts can contain comments:

    envar @PATH : [$(@PATH);]
                # [C:\Java\bin;]
                  [C:\Ruby\bin;]    # Ruby ruby ruby, when will you be mine. Whooo
                  [C:\chicken\bin;]
    MYVAR +
    #MYVAR -

   
    This is really all you need to know. To manage your variables you can keep them
    in multiple files and load them as you need. You can write scripts that
    completely replace some variables, Base Profiles, and scripts that extend
    those profiles with additional paths, Incremental Profiles. This is not a feature, 
    it just a recommended work-flow you can choose to adopt.

Help Message:

Syntax:

# This is a comment
VARIABLE : [THIS IS VALUE] # sets **user** environment variable 
                           # %VARIABLE% to "THIS IS VALUE"

VARIABLE : [THIS]          # exactly the same, just split up in two parts
           [IS VALUE] 
                           
@VARIABLE : [VALUE]        # here VARIABLE is a **system** environment variable
                           # as opposed to **user**

VARIABLE +                 # creates a new user variable, without setting it's value
VARIABLE -                 # removes a user variable
                           # (space before + and - is optional)

@VARIABLE -                # same but for a system variable

@PATH : [$(@PATH);]        # $(...) blocks are used to reference values of variables
        [C:\ruby\bin;]       
        [$(JAVA_HOME)\bin;]  

@PATH : [$(shell command)] # command evaluation

Statements can be written next to each other or on separate lines:

    @VARIABLE: [VALUE] VARIABLE+ @PATH: [$(%PATH%)] [C:\ruby\bin]  

Usage:

    envar {SCRIPT LINE | -{i|e} [SCRIPT FILE]}

    -i : import script from file if such is specified, or read it from 
         standard input

    -e : export current state of all variables into a script file or standard 
         output if no file is specified. Each found environment variable 
         produces a set statement in generated script file with it's current
         name and value.

EXECUTING SCRIPTS:

    You can pass a script directly as an argument or read it from file 
    or standard input.

Examples:

    Directly passing a script line:
        envar JAVA_HOME : [C:\Java\bin] RUBY_HOME- # set JAVA_HOME 
                                                   # and remove RUBY_HOME

    Reading script from a file:
        envar -i script_file

    Passing a script using pipes (notice missing file parameter):
        envar -i < script_file
    OR
        echo "JAVA_HOME : [C:\Java\bin]" | envar -i

GENERATING SCRIPTS:
    
    It may be beneficial to be able to save all current user and system environment 
    variables into a file for later loading. It can be accomplished with -e 
    option (export)

Examples:

    Exporting to file:
        envar -e saved_file 

    Exporting to standard output:
        envar -e

    Exporting to file through a pipe:
        envar -e > saved_file

Known Issues:

-   Setting batch variables inside shell blocks doesn't evaluate them to new values
    $(shell set VAR=10
            echo %VAR%) # doesn't evaluate VAR to 10, because vars are evaluated 
                        # before command execution

-   Programs need to be restarted for changes in variables to propagate.
    Although no restarting required for Envar to work correctly since it's working
    directly with registry.

-   Changes to variables are not immidiately flushed during script execution

-   No way to specify variable type, PATH variables need to be REG_EXPAND_SZ, 
    Other variables may benefit from being REG_SZ. New default will be expandable,
    but you will be able to have REG_SZ with = operator.